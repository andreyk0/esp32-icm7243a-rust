use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported

use core::str;
use embedded_svc::{http::Method, io::Write};

use esp_idf_hal::gpio;
use esp_idf_hal::gpio::{Output, PinDriver};
use esp_idf_hal::prelude::*;

use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    http::server::{Configuration, EspHttpServer},
};
use std::{
    mem,
    sync::{Arc, Mutex},
    thread::sleep,
    time::Duration,
};

use once_cell::sync::Lazy;

use anyhow::Result;

mod wifi;
use wifi::assert_connected;
use wifi::wifi;

mod display;
use display::*;

mod circ;
use circ::*;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

static TEXT_PLAIN_UTF8: [(&str, &str); 1] = [("Content-Type", "text/plain; charset=utf-8")];
static OK: &'static [u8] = "Ok".as_bytes();

static MESSAGE: Lazy<Arc<Mutex<Option<Vec<u8>>>>> = Lazy::new(|| Arc::new(Mutex::new(None)));
static LED: Lazy<Arc<Mutex<Option<PinDriver<gpio::Gpio15, Output>>>>> =
    Lazy::new(|| Arc::new(Mutex::new(None)));

fn blink() -> Result<()> {
    for led in &mut *LED.lock().unwrap() {
        led.toggle()?;
    }
    Ok(())
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_sys::link_patches();

    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    // GPIO
    let pins = peripherals.pins;
    let led = PinDriver::output(pins.gpio15)?;
    {
        let mut l = LED.lock().unwrap();
        *l = Some(led);
    }

    let a0 = PinDriver::output(pins.gpio3)?;
    let a1 = PinDriver::output(pins.gpio5)?;
    let a2 = PinDriver::output(pins.gpio7)?;

    let cswr = PinDriver::output(pins.gpio9)?;

    let d0 = PinDriver::output(pins.gpio39)?;
    let d1 = PinDriver::output(pins.gpio37)?;
    let d2 = PinDriver::output(pins.gpio35)?;
    let d3 = PinDriver::output(pins.gpio33)?;
    let d4 = PinDriver::output(pins.gpio18)?;
    let d5 = PinDriver::output(pins.gpio16)?;

    let mut display = Display::new(a0, a1, a2, cswr, d0, d1, d2, d3, d4, d5)?;

    // Set the HTTP server
    let mut server = EspHttpServer::new(&Configuration::default())?;

    server.fn_handler("/", Method::Get, |request| {
        blink()?;
        let mut response = request.into_response(200, Some("OK"), &TEXT_PLAIN_UTF8)?;
        response.write_all(OK)?;
        Ok(())
    })?;
    server.fn_handler("/", Method::Post, |mut request| {
        blink()?;
        let (_, r) = request.split();
        let mut chars = vec![0; 1024];
        let n = r.read(chars.as_mut())?;
        chars.resize(n, 0);
        let mut response = request.into_response(200, Some("OK"), &TEXT_PLAIN_UTF8)?;
        let mut message = MESSAGE.lock()?;
        *message = Some(chars);
        response.write_all(OK)?;
        Ok(())
    })?;

    let mut msg = Circ::new(vec!['.' as u8; 8]);

    loop {
        assert_connected(&wifi)?;

        msg = {
            let mut message = MESSAGE.lock().unwrap();
            match mem::replace(&mut *message, None) {
                Some(chars) => Circ::new(chars),
                None => msg,
            }
        };

        for _ in 0..NUM_CHARS {
            if let Some((a, c)) = msg.next() {
                display.display_char(a, c)?;
            }
        }

        sleep(Duration::from_millis(250));
    }
}
